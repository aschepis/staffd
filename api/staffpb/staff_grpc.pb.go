// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: staff.proto

package staffpb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ChatService_Chat_FullMethodName              = "/staff.v1.ChatService/Chat"
	ChatService_GetOrCreateThread_FullMethodName = "/staff.v1.ChatService/GetOrCreateThread"
	ChatService_LoadHistory_FullMethodName       = "/staff.v1.ChatService/LoadHistory"
	ChatService_ResetContext_FullMethodName      = "/staff.v1.ChatService/ResetContext"
	ChatService_CompressContext_FullMethodName   = "/staff.v1.ChatService/CompressContext"
)

// ChatServiceClient is the client API for ChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChatServiceClient interface {
	// Send a message and receive streaming response events
	Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatEvent], error)
	// Get or create a conversation thread for an agent
	GetOrCreateThread(ctx context.Context, in *GetThreadRequest, opts ...grpc.CallOption) (*GetThreadResponse, error)
	// Load conversation history for a thread
	LoadHistory(ctx context.Context, in *LoadHistoryRequest, opts ...grpc.CallOption) (*LoadHistoryResponse, error)
	// Reset conversation context (clears history for LLM but preserves for display)
	ResetContext(ctx context.Context, in *ContextRequest, opts ...grpc.CallOption) (*ContextResponse, error)
	// Compress conversation context (summarizes and resets)
	CompressContext(ctx context.Context, in *ContextRequest, opts ...grpc.CallOption) (*ContextResponse, error)
}

type chatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatServiceClient(cc grpc.ClientConnInterface) ChatServiceClient {
	return &chatServiceClient{cc}
}

func (c *chatServiceClient) Chat(ctx context.Context, in *ChatRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[0], ChatService_Chat_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ChatRequest, ChatEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_ChatClient = grpc.ServerStreamingClient[ChatEvent]

func (c *chatServiceClient) GetOrCreateThread(ctx context.Context, in *GetThreadRequest, opts ...grpc.CallOption) (*GetThreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetThreadResponse)
	err := c.cc.Invoke(ctx, ChatService_GetOrCreateThread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) LoadHistory(ctx context.Context, in *LoadHistoryRequest, opts ...grpc.CallOption) (*LoadHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoadHistoryResponse)
	err := c.cc.Invoke(ctx, ChatService_LoadHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) ResetContext(ctx context.Context, in *ContextRequest, opts ...grpc.CallOption) (*ContextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContextResponse)
	err := c.cc.Invoke(ctx, ChatService_ResetContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) CompressContext(ctx context.Context, in *ContextRequest, opts ...grpc.CallOption) (*ContextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ContextResponse)
	err := c.cc.Invoke(ctx, ChatService_CompressContext_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChatServiceServer is the server API for ChatService service.
// All implementations must embed UnimplementedChatServiceServer
// for forward compatibility.
type ChatServiceServer interface {
	// Send a message and receive streaming response events
	Chat(*ChatRequest, grpc.ServerStreamingServer[ChatEvent]) error
	// Get or create a conversation thread for an agent
	GetOrCreateThread(context.Context, *GetThreadRequest) (*GetThreadResponse, error)
	// Load conversation history for a thread
	LoadHistory(context.Context, *LoadHistoryRequest) (*LoadHistoryResponse, error)
	// Reset conversation context (clears history for LLM but preserves for display)
	ResetContext(context.Context, *ContextRequest) (*ContextResponse, error)
	// Compress conversation context (summarizes and resets)
	CompressContext(context.Context, *ContextRequest) (*ContextResponse, error)
	mustEmbedUnimplementedChatServiceServer()
}

// UnimplementedChatServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChatServiceServer struct{}

func (UnimplementedChatServiceServer) Chat(*ChatRequest, grpc.ServerStreamingServer[ChatEvent]) error {
	return status.Error(codes.Unimplemented, "method Chat not implemented")
}
func (UnimplementedChatServiceServer) GetOrCreateThread(context.Context, *GetThreadRequest) (*GetThreadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOrCreateThread not implemented")
}
func (UnimplementedChatServiceServer) LoadHistory(context.Context, *LoadHistoryRequest) (*LoadHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LoadHistory not implemented")
}
func (UnimplementedChatServiceServer) ResetContext(context.Context, *ContextRequest) (*ContextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResetContext not implemented")
}
func (UnimplementedChatServiceServer) CompressContext(context.Context, *ContextRequest) (*ContextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CompressContext not implemented")
}
func (UnimplementedChatServiceServer) mustEmbedUnimplementedChatServiceServer() {}
func (UnimplementedChatServiceServer) testEmbeddedByValue()                     {}

// UnsafeChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatServiceServer will
// result in compilation errors.
type UnsafeChatServiceServer interface {
	mustEmbedUnimplementedChatServiceServer()
}

func RegisterChatServiceServer(s grpc.ServiceRegistrar, srv ChatServiceServer) {
	// If the following call panics, it indicates UnimplementedChatServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChatService_ServiceDesc, srv)
}

func _ChatService_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChatRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).Chat(m, &grpc.GenericServerStream[ChatRequest, ChatEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_ChatServer = grpc.ServerStreamingServer[ChatEvent]

func _ChatService_GetOrCreateThread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetThreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetOrCreateThread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_GetOrCreateThread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetOrCreateThread(ctx, req.(*GetThreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_LoadHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoadHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).LoadHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_LoadHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).LoadHistory(ctx, req.(*LoadHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_ResetContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).ResetContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_ResetContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).ResetContext(ctx, req.(*ContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_CompressContext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).CompressContext(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_CompressContext_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).CompressContext(ctx, req.(*ContextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChatService_ServiceDesc is the grpc.ServiceDesc for ChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "staff.v1.ChatService",
	HandlerType: (*ChatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOrCreateThread",
			Handler:    _ChatService_GetOrCreateThread_Handler,
		},
		{
			MethodName: "LoadHistory",
			Handler:    _ChatService_LoadHistory_Handler,
		},
		{
			MethodName: "ResetContext",
			Handler:    _ChatService_ResetContext_Handler,
		},
		{
			MethodName: "CompressContext",
			Handler:    _ChatService_CompressContext_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Chat",
			Handler:       _ChatService_Chat_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "staff.proto",
}

const (
	AgentService_ListAgents_FullMethodName    = "/staff.v1.AgentService/ListAgents"
	AgentService_GetAgent_FullMethodName      = "/staff.v1.AgentService/GetAgent"
	AgentService_GetAgentState_FullMethodName = "/staff.v1.AgentService/GetAgentState"
	AgentService_GetAgentStats_FullMethodName = "/staff.v1.AgentService/GetAgentStats"
	AgentService_WatchStates_FullMethodName   = "/staff.v1.AgentService/WatchStates"
)

// AgentServiceClient is the client API for AgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AgentServiceClient interface {
	// List all configured agents
	ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	// Get detailed information about a specific agent
	GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*Agent, error)
	// Get current state of an agent
	GetAgentState(ctx context.Context, in *GetAgentStateRequest, opts ...grpc.CallOption) (*AgentState, error)
	// Get statistics for an agent
	GetAgentStats(ctx context.Context, in *GetAgentStatsRequest, opts ...grpc.CallOption) (*AgentStats, error)
	// Stream agent state changes in real-time
	WatchStates(ctx context.Context, in *WatchStatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AgentState], error)
}

type agentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentServiceClient(cc grpc.ClientConnInterface) AgentServiceClient {
	return &agentServiceClient{cc}
}

func (c *agentServiceClient) ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, AgentService_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*Agent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Agent)
	err := c.cc.Invoke(ctx, AgentService_GetAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgentState(ctx context.Context, in *GetAgentStateRequest, opts ...grpc.CallOption) (*AgentState, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentState)
	err := c.cc.Invoke(ctx, AgentService_GetAgentState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgentStats(ctx context.Context, in *GetAgentStatsRequest, opts ...grpc.CallOption) (*AgentStats, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentStats)
	err := c.cc.Invoke(ctx, AgentService_GetAgentStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) WatchStates(ctx context.Context, in *WatchStatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AgentState], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentService_ServiceDesc.Streams[0], AgentService_WatchStates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchStatesRequest, AgentState]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_WatchStatesClient = grpc.ServerStreamingClient[AgentState]

// AgentServiceServer is the server API for AgentService service.
// All implementations must embed UnimplementedAgentServiceServer
// for forward compatibility.
type AgentServiceServer interface {
	// List all configured agents
	ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error)
	// Get detailed information about a specific agent
	GetAgent(context.Context, *GetAgentRequest) (*Agent, error)
	// Get current state of an agent
	GetAgentState(context.Context, *GetAgentStateRequest) (*AgentState, error)
	// Get statistics for an agent
	GetAgentStats(context.Context, *GetAgentStatsRequest) (*AgentStats, error)
	// Stream agent state changes in real-time
	WatchStates(*WatchStatesRequest, grpc.ServerStreamingServer[AgentState]) error
	mustEmbedUnimplementedAgentServiceServer()
}

// UnimplementedAgentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServiceServer struct{}

func (UnimplementedAgentServiceServer) ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedAgentServiceServer) GetAgent(context.Context, *GetAgentRequest) (*Agent, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgent not implemented")
}
func (UnimplementedAgentServiceServer) GetAgentState(context.Context, *GetAgentStateRequest) (*AgentState, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgentState not implemented")
}
func (UnimplementedAgentServiceServer) GetAgentStats(context.Context, *GetAgentStatsRequest) (*AgentStats, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgentStats not implemented")
}
func (UnimplementedAgentServiceServer) WatchStates(*WatchStatesRequest, grpc.ServerStreamingServer[AgentState]) error {
	return status.Error(codes.Unimplemented, "method WatchStates not implemented")
}
func (UnimplementedAgentServiceServer) mustEmbedUnimplementedAgentServiceServer() {}
func (UnimplementedAgentServiceServer) testEmbeddedByValue()                      {}

// UnsafeAgentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServiceServer will
// result in compilation errors.
type UnsafeAgentServiceServer interface {
	mustEmbedUnimplementedAgentServiceServer()
}

func RegisterAgentServiceServer(s grpc.ServiceRegistrar, srv AgentServiceServer) {
	// If the following call panics, it indicates UnimplementedAgentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentService_ServiceDesc, srv)
}

func _AgentService_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ListAgents(ctx, req.(*ListAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgent(ctx, req.(*GetAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgentState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgentState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgentState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgentState(ctx, req.(*GetAgentStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgentStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgentStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgentStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgentStats(ctx, req.(*GetAgentStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_WatchStates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchStatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServiceServer).WatchStates(m, &grpc.GenericServerStream[WatchStatesRequest, AgentState]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_WatchStatesServer = grpc.ServerStreamingServer[AgentState]

// AgentService_ServiceDesc is the grpc.ServiceDesc for AgentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "staff.v1.AgentService",
	HandlerType: (*AgentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAgents",
			Handler:    _AgentService_ListAgents_Handler,
		},
		{
			MethodName: "GetAgent",
			Handler:    _AgentService_GetAgent_Handler,
		},
		{
			MethodName: "GetAgentState",
			Handler:    _AgentService_GetAgentState_Handler,
		},
		{
			MethodName: "GetAgentStats",
			Handler:    _AgentService_GetAgentStats_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchStates",
			Handler:       _AgentService_WatchStates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "staff.proto",
}

const (
	InboxService_ListItems_FullMethodName = "/staff.v1.InboxService/ListItems"
	InboxService_Archive_FullMethodName   = "/staff.v1.InboxService/Archive"
	InboxService_Watch_FullMethodName     = "/staff.v1.InboxService/Watch"
)

// InboxServiceClient is the client API for InboxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InboxServiceClient interface {
	// List inbox items
	ListItems(ctx context.Context, in *ListInboxRequest, opts ...grpc.CallOption) (*ListInboxResponse, error)
	// Archive an inbox item
	Archive(ctx context.Context, in *ArchiveRequest, opts ...grpc.CallOption) (*ArchiveResponse, error)
	// Stream new inbox items as they arrive
	Watch(ctx context.Context, in *WatchInboxRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InboxItem], error)
}

type inboxServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInboxServiceClient(cc grpc.ClientConnInterface) InboxServiceClient {
	return &inboxServiceClient{cc}
}

func (c *inboxServiceClient) ListItems(ctx context.Context, in *ListInboxRequest, opts ...grpc.CallOption) (*ListInboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListInboxResponse)
	err := c.cc.Invoke(ctx, InboxService_ListItems_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inboxServiceClient) Archive(ctx context.Context, in *ArchiveRequest, opts ...grpc.CallOption) (*ArchiveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArchiveResponse)
	err := c.cc.Invoke(ctx, InboxService_Archive_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inboxServiceClient) Watch(ctx context.Context, in *WatchInboxRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InboxItem], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &InboxService_ServiceDesc.Streams[0], InboxService_Watch_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WatchInboxRequest, InboxItem]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type InboxService_WatchClient = grpc.ServerStreamingClient[InboxItem]

// InboxServiceServer is the server API for InboxService service.
// All implementations must embed UnimplementedInboxServiceServer
// for forward compatibility.
type InboxServiceServer interface {
	// List inbox items
	ListItems(context.Context, *ListInboxRequest) (*ListInboxResponse, error)
	// Archive an inbox item
	Archive(context.Context, *ArchiveRequest) (*ArchiveResponse, error)
	// Stream new inbox items as they arrive
	Watch(*WatchInboxRequest, grpc.ServerStreamingServer[InboxItem]) error
	mustEmbedUnimplementedInboxServiceServer()
}

// UnimplementedInboxServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedInboxServiceServer struct{}

func (UnimplementedInboxServiceServer) ListItems(context.Context, *ListInboxRequest) (*ListInboxResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListItems not implemented")
}
func (UnimplementedInboxServiceServer) Archive(context.Context, *ArchiveRequest) (*ArchiveResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Archive not implemented")
}
func (UnimplementedInboxServiceServer) Watch(*WatchInboxRequest, grpc.ServerStreamingServer[InboxItem]) error {
	return status.Error(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedInboxServiceServer) mustEmbedUnimplementedInboxServiceServer() {}
func (UnimplementedInboxServiceServer) testEmbeddedByValue()                      {}

// UnsafeInboxServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InboxServiceServer will
// result in compilation errors.
type UnsafeInboxServiceServer interface {
	mustEmbedUnimplementedInboxServiceServer()
}

func RegisterInboxServiceServer(s grpc.ServiceRegistrar, srv InboxServiceServer) {
	// If the following call panics, it indicates UnimplementedInboxServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&InboxService_ServiceDesc, srv)
}

func _InboxService_ListItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InboxServiceServer).ListItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InboxService_ListItems_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InboxServiceServer).ListItems(ctx, req.(*ListInboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InboxService_Archive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InboxServiceServer).Archive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InboxService_Archive_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InboxServiceServer).Archive(ctx, req.(*ArchiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InboxService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchInboxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InboxServiceServer).Watch(m, &grpc.GenericServerStream[WatchInboxRequest, InboxItem]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type InboxService_WatchServer = grpc.ServerStreamingServer[InboxItem]

// InboxService_ServiceDesc is the grpc.ServiceDesc for InboxService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InboxService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "staff.v1.InboxService",
	HandlerType: (*InboxServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListItems",
			Handler:    _InboxService_ListItems_Handler,
		},
		{
			MethodName: "Archive",
			Handler:    _InboxService_Archive_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _InboxService_Watch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "staff.proto",
}

const (
	MemoryService_Search_FullMethodName = "/staff.v1.MemoryService/Search"
	MemoryService_Store_FullMethodName  = "/staff.v1.MemoryService/Store"
	MemoryService_Dump_FullMethodName   = "/staff.v1.MemoryService/Dump"
	MemoryService_Clear_FullMethodName  = "/staff.v1.MemoryService/Clear"
)

// MemoryServiceClient is the client API for MemoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MemoryServiceClient interface {
	// Search memories
	Search(ctx context.Context, in *SearchMemoryRequest, opts ...grpc.CallOption) (*SearchMemoryResponse, error)
	// Store a memory item
	Store(ctx context.Context, in *StoreMemoryRequest, opts ...grpc.CallOption) (*StoreMemoryResponse, error)
	// Dump all memory to file (admin operation)
	Dump(ctx context.Context, in *DumpMemoryRequest, opts ...grpc.CallOption) (*DumpMemoryResponse, error)
	// Clear all memory (admin operation)
	Clear(ctx context.Context, in *ClearMemoryRequest, opts ...grpc.CallOption) (*ClearMemoryResponse, error)
}

type memoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMemoryServiceClient(cc grpc.ClientConnInterface) MemoryServiceClient {
	return &memoryServiceClient{cc}
}

func (c *memoryServiceClient) Search(ctx context.Context, in *SearchMemoryRequest, opts ...grpc.CallOption) (*SearchMemoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchMemoryResponse)
	err := c.cc.Invoke(ctx, MemoryService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Store(ctx context.Context, in *StoreMemoryRequest, opts ...grpc.CallOption) (*StoreMemoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreMemoryResponse)
	err := c.cc.Invoke(ctx, MemoryService_Store_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Dump(ctx context.Context, in *DumpMemoryRequest, opts ...grpc.CallOption) (*DumpMemoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DumpMemoryResponse)
	err := c.cc.Invoke(ctx, MemoryService_Dump_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *memoryServiceClient) Clear(ctx context.Context, in *ClearMemoryRequest, opts ...grpc.CallOption) (*ClearMemoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearMemoryResponse)
	err := c.cc.Invoke(ctx, MemoryService_Clear_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MemoryServiceServer is the server API for MemoryService service.
// All implementations must embed UnimplementedMemoryServiceServer
// for forward compatibility.
type MemoryServiceServer interface {
	// Search memories
	Search(context.Context, *SearchMemoryRequest) (*SearchMemoryResponse, error)
	// Store a memory item
	Store(context.Context, *StoreMemoryRequest) (*StoreMemoryResponse, error)
	// Dump all memory to file (admin operation)
	Dump(context.Context, *DumpMemoryRequest) (*DumpMemoryResponse, error)
	// Clear all memory (admin operation)
	Clear(context.Context, *ClearMemoryRequest) (*ClearMemoryResponse, error)
	mustEmbedUnimplementedMemoryServiceServer()
}

// UnimplementedMemoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMemoryServiceServer struct{}

func (UnimplementedMemoryServiceServer) Search(context.Context, *SearchMemoryRequest) (*SearchMemoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedMemoryServiceServer) Store(context.Context, *StoreMemoryRequest) (*StoreMemoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Store not implemented")
}
func (UnimplementedMemoryServiceServer) Dump(context.Context, *DumpMemoryRequest) (*DumpMemoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Dump not implemented")
}
func (UnimplementedMemoryServiceServer) Clear(context.Context, *ClearMemoryRequest) (*ClearMemoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Clear not implemented")
}
func (UnimplementedMemoryServiceServer) mustEmbedUnimplementedMemoryServiceServer() {}
func (UnimplementedMemoryServiceServer) testEmbeddedByValue()                       {}

// UnsafeMemoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MemoryServiceServer will
// result in compilation errors.
type UnsafeMemoryServiceServer interface {
	mustEmbedUnimplementedMemoryServiceServer()
}

func RegisterMemoryServiceServer(s grpc.ServiceRegistrar, srv MemoryServiceServer) {
	// If the following call panics, it indicates UnimplementedMemoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MemoryService_ServiceDesc, srv)
}

func _MemoryService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Search(ctx, req.(*SearchMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Store_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Store(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Store_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Store(ctx, req.(*StoreMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Dump_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Dump(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Dump_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Dump(ctx, req.(*DumpMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MemoryService_Clear_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MemoryServiceServer).Clear(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MemoryService_Clear_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MemoryServiceServer).Clear(ctx, req.(*ClearMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MemoryService_ServiceDesc is the grpc.ServiceDesc for MemoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MemoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "staff.v1.MemoryService",
	HandlerType: (*MemoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _MemoryService_Search_Handler,
		},
		{
			MethodName: "Store",
			Handler:    _MemoryService_Store_Handler,
		},
		{
			MethodName: "Dump",
			Handler:    _MemoryService_Dump_Handler,
		},
		{
			MethodName: "Clear",
			Handler:    _MemoryService_Clear_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "staff.proto",
}

const (
	SystemService_GetInfo_FullMethodName            = "/staff.v1.SystemService/GetInfo"
	SystemService_ListTools_FullMethodName          = "/staff.v1.SystemService/ListTools"
	SystemService_ListMCPServers_FullMethodName     = "/staff.v1.SystemService/ListMCPServers"
	SystemService_DumpToolSchemas_FullMethodName    = "/staff.v1.SystemService/DumpToolSchemas"
	SystemService_DumpConversations_FullMethodName  = "/staff.v1.SystemService/DumpConversations"
	SystemService_ClearConversations_FullMethodName = "/staff.v1.SystemService/ClearConversations"
	SystemService_ResetStats_FullMethodName         = "/staff.v1.SystemService/ResetStats"
	SystemService_DumpInbox_FullMethodName          = "/staff.v1.SystemService/DumpInbox"
	SystemService_ClearInbox_FullMethodName         = "/staff.v1.SystemService/ClearInbox"
)

// SystemServiceClient is the client API for SystemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SystemServiceClient interface {
	// Get daemon status and version info
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*SystemInfo, error)
	// List all registered tools
	ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error)
	// List MCP servers and their status
	ListMCPServers(ctx context.Context, in *ListMCPServersRequest, opts ...grpc.CallOption) (*ListMCPServersResponse, error)
	// Dump tool schemas to file
	DumpToolSchemas(ctx context.Context, in *DumpToolSchemasRequest, opts ...grpc.CallOption) (*DumpToolSchemasResponse, error)
	// Dump conversations to files
	DumpConversations(ctx context.Context, in *DumpConversationsRequest, opts ...grpc.CallOption) (*DumpConversationsResponse, error)
	// Clear all conversations
	ClearConversations(ctx context.Context, in *ClearConversationsRequest, opts ...grpc.CallOption) (*ClearConversationsResponse, error)
	// Reset agent stats
	ResetStats(ctx context.Context, in *ResetStatsRequest, opts ...grpc.CallOption) (*ResetStatsResponse, error)
	// Dump inbox to file
	DumpInbox(ctx context.Context, in *DumpInboxRequest, opts ...grpc.CallOption) (*DumpInboxResponse, error)
	// Clear inbox
	ClearInbox(ctx context.Context, in *ClearInboxRequest, opts ...grpc.CallOption) (*ClearInboxResponse, error)
}

type systemServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSystemServiceClient(cc grpc.ClientConnInterface) SystemServiceClient {
	return &systemServiceClient{cc}
}

func (c *systemServiceClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*SystemInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SystemInfo)
	err := c.cc.Invoke(ctx, SystemService_GetInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListToolsResponse)
	err := c.cc.Invoke(ctx, SystemService_ListTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) ListMCPServers(ctx context.Context, in *ListMCPServersRequest, opts ...grpc.CallOption) (*ListMCPServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMCPServersResponse)
	err := c.cc.Invoke(ctx, SystemService_ListMCPServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) DumpToolSchemas(ctx context.Context, in *DumpToolSchemasRequest, opts ...grpc.CallOption) (*DumpToolSchemasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DumpToolSchemasResponse)
	err := c.cc.Invoke(ctx, SystemService_DumpToolSchemas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) DumpConversations(ctx context.Context, in *DumpConversationsRequest, opts ...grpc.CallOption) (*DumpConversationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DumpConversationsResponse)
	err := c.cc.Invoke(ctx, SystemService_DumpConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) ClearConversations(ctx context.Context, in *ClearConversationsRequest, opts ...grpc.CallOption) (*ClearConversationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearConversationsResponse)
	err := c.cc.Invoke(ctx, SystemService_ClearConversations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) ResetStats(ctx context.Context, in *ResetStatsRequest, opts ...grpc.CallOption) (*ResetStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetStatsResponse)
	err := c.cc.Invoke(ctx, SystemService_ResetStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) DumpInbox(ctx context.Context, in *DumpInboxRequest, opts ...grpc.CallOption) (*DumpInboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DumpInboxResponse)
	err := c.cc.Invoke(ctx, SystemService_DumpInbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) ClearInbox(ctx context.Context, in *ClearInboxRequest, opts ...grpc.CallOption) (*ClearInboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearInboxResponse)
	err := c.cc.Invoke(ctx, SystemService_ClearInbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SystemServiceServer is the server API for SystemService service.
// All implementations must embed UnimplementedSystemServiceServer
// for forward compatibility.
type SystemServiceServer interface {
	// Get daemon status and version info
	GetInfo(context.Context, *GetInfoRequest) (*SystemInfo, error)
	// List all registered tools
	ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error)
	// List MCP servers and their status
	ListMCPServers(context.Context, *ListMCPServersRequest) (*ListMCPServersResponse, error)
	// Dump tool schemas to file
	DumpToolSchemas(context.Context, *DumpToolSchemasRequest) (*DumpToolSchemasResponse, error)
	// Dump conversations to files
	DumpConversations(context.Context, *DumpConversationsRequest) (*DumpConversationsResponse, error)
	// Clear all conversations
	ClearConversations(context.Context, *ClearConversationsRequest) (*ClearConversationsResponse, error)
	// Reset agent stats
	ResetStats(context.Context, *ResetStatsRequest) (*ResetStatsResponse, error)
	// Dump inbox to file
	DumpInbox(context.Context, *DumpInboxRequest) (*DumpInboxResponse, error)
	// Clear inbox
	ClearInbox(context.Context, *ClearInboxRequest) (*ClearInboxResponse, error)
	mustEmbedUnimplementedSystemServiceServer()
}

// UnimplementedSystemServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSystemServiceServer struct{}

func (UnimplementedSystemServiceServer) GetInfo(context.Context, *GetInfoRequest) (*SystemInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetInfo not implemented")
}
func (UnimplementedSystemServiceServer) ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTools not implemented")
}
func (UnimplementedSystemServiceServer) ListMCPServers(context.Context, *ListMCPServersRequest) (*ListMCPServersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMCPServers not implemented")
}
func (UnimplementedSystemServiceServer) DumpToolSchemas(context.Context, *DumpToolSchemasRequest) (*DumpToolSchemasResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DumpToolSchemas not implemented")
}
func (UnimplementedSystemServiceServer) DumpConversations(context.Context, *DumpConversationsRequest) (*DumpConversationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DumpConversations not implemented")
}
func (UnimplementedSystemServiceServer) ClearConversations(context.Context, *ClearConversationsRequest) (*ClearConversationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearConversations not implemented")
}
func (UnimplementedSystemServiceServer) ResetStats(context.Context, *ResetStatsRequest) (*ResetStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResetStats not implemented")
}
func (UnimplementedSystemServiceServer) DumpInbox(context.Context, *DumpInboxRequest) (*DumpInboxResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DumpInbox not implemented")
}
func (UnimplementedSystemServiceServer) ClearInbox(context.Context, *ClearInboxRequest) (*ClearInboxResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearInbox not implemented")
}
func (UnimplementedSystemServiceServer) mustEmbedUnimplementedSystemServiceServer() {}
func (UnimplementedSystemServiceServer) testEmbeddedByValue()                       {}

// UnsafeSystemServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SystemServiceServer will
// result in compilation errors.
type UnsafeSystemServiceServer interface {
	mustEmbedUnimplementedSystemServiceServer()
}

func RegisterSystemServiceServer(s grpc.ServiceRegistrar, srv SystemServiceServer) {
	// If the following call panics, it indicates UnimplementedSystemServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SystemService_ServiceDesc, srv)
}

func _SystemService_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemService_GetInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_ListTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).ListTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemService_ListTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).ListTools(ctx, req.(*ListToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_ListMCPServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMCPServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).ListMCPServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemService_ListMCPServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).ListMCPServers(ctx, req.(*ListMCPServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_DumpToolSchemas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpToolSchemasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).DumpToolSchemas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemService_DumpToolSchemas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).DumpToolSchemas(ctx, req.(*DumpToolSchemasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_DumpConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).DumpConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemService_DumpConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).DumpConversations(ctx, req.(*DumpConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_ClearConversations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearConversationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).ClearConversations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemService_ClearConversations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).ClearConversations(ctx, req.(*ClearConversationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_ResetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).ResetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemService_ResetStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).ResetStats(ctx, req.(*ResetStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_DumpInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpInboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).DumpInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemService_DumpInbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).DumpInbox(ctx, req.(*DumpInboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_ClearInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearInboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).ClearInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SystemService_ClearInbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).ClearInbox(ctx, req.(*ClearInboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SystemService_ServiceDesc is the grpc.ServiceDesc for SystemService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SystemService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "staff.v1.SystemService",
	HandlerType: (*SystemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfo",
			Handler:    _SystemService_GetInfo_Handler,
		},
		{
			MethodName: "ListTools",
			Handler:    _SystemService_ListTools_Handler,
		},
		{
			MethodName: "ListMCPServers",
			Handler:    _SystemService_ListMCPServers_Handler,
		},
		{
			MethodName: "DumpToolSchemas",
			Handler:    _SystemService_DumpToolSchemas_Handler,
		},
		{
			MethodName: "DumpConversations",
			Handler:    _SystemService_DumpConversations_Handler,
		},
		{
			MethodName: "ClearConversations",
			Handler:    _SystemService_ClearConversations_Handler,
		},
		{
			MethodName: "ResetStats",
			Handler:    _SystemService_ResetStats_Handler,
		},
		{
			MethodName: "DumpInbox",
			Handler:    _SystemService_DumpInbox_Handler,
		},
		{
			MethodName: "ClearInbox",
			Handler:    _SystemService_ClearInbox_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "staff.proto",
}
